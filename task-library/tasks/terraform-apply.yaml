---
Name: "terraform-apply"
Description: "A task run Terraform Plans"
Documentation: |
  Runs one or more Terraform Plan templates as defined by the
  ``terraform/plan-templates`` variable in the stage calling the task.

  Requires an ``terraform`` context.

  The ``terraform apply`` is only called once.  All plans in the list 
  are generated first.  If sequential operations beyond the plan are needed, use
  multiple calls to this task.

  Information can be chained together by having the plan output saved
  on the machine as ``Param.terraform-var/[output var]``.

  Only Name, UUID, Address of the Machine are automatically passed into the plan;
  however, the plans can use the .Param and .ParamExists template 
  to pull any value needed.

  Terraform State is stored as a Param 'terraform/tfstate' the Machine after first
  execution.  It is then retrieved for all subsequent runs so that Terraform
  is able to correctly use it's state values.

  For developers: use the `terraform/plan-automation` parameter if you needed
  have a task that uses terraform behind the scenes.  This parameter is automatically
  removed from machines (not profiles!) automatically on destroy.

  The synchronize.sh script is used by "local-exec" to connect/update/destroy machines
  from Terraform into Digital Rebar.

  To match existing machines, cloud/instance-id and cloud/provider are used first.  Name is used as a backup.

  When updating/creating sets the Params for
    - cloud/instance-id
    - cloud/provider
    - machine/PXE
    - machine/type
    - machine/tags

  Notes:
  * having SSH keys requires using the 'rsa-key-create' generator task.
  * if creating cloud machines, use the 'ansible-join-up' task for join
ExtraClaims:
  - scope: "machines"
    action: "*"
    specific: "*"
  - scope: "workflows"
    action: "get"
    specific: "*"
RequiredParams:
  - terraform/plan-action
  - terraform/plan-automation
  - terraform/plan-templates
  - terraform/next-workflow
  - terraform/map-ip-address
  - terraform/map-instance-name
  - cloud/provider
OptionalParams:
  - cluster/profile
  - terraform/tfstate
  - terraform/plan-templates
  - rsa/key-user
  - rsa/key-public
Templates:
  - Name: "DRP Machine Sync"
    Path: "synchronize.sh"
    Contents: |-
      #!/bin/bash
      # RackN Copyright 2021
      {{ $cloud := .Param "cloud/provider" }}
      {{ $templates := concat (.Param "terraform/plan-automation") (.Param "terraform/plan-templates") -}}

      echo "====== Synchronize DRP<>Terraform for {{ $cloud }}  ======"
      {{template "setup.tmpl" .}}

      {{ if (hasKey (.Param "terraform/map-ip-address") $cloud) }}
        JQADDRESS="{{ get (.Param "terraform/map-ip-address") $cloud }}"
        echo "  Using terraform/map-ip-address = $JQADDRESS"
      {{ else }}
        JQADDRESS="{{ get (.Param "terraform/map-ip-address") "default" }}"
        echo "  WARNING: Missing terraform/map-ip-address value for {{ $cloud }}. Using default $JQADDRESS"
      {{ end }}

      {{ if (hasKey (.Param "terraform/map-instance-name") $cloud) }}
        JQNAME="{{ get (.Param "terraform/map-instance-name") $cloud }}"
        echo "  Using terraform/map-instance-name = $JQNAME"
      {{ else }}
        JQNAME="{{ get (.Param "terraform/map-instance-name") "default" }}"
        echo "   WARNING: Missing terraform/map-instance-name value for {{ $cloud }}. Using default $JQNAME"
      {{ end }}

      {{ if .ParamExists "cloud/provider-icons" }}
        {{ if hasKey (.Param "cloud/provider-icons") $cloud }}
          CLOUDICON="{{ get (.Param "cloud/provider-icons") $cloud }}"
        {{ else }}
          CLOUDICON="{{ get (.Param "cloud/provider-icons") "default" }}"
        {{ end }}
      {{ end }}

      TFSELF="$1"
      {{ if .ParamExists "rs-debug-enable" }}
      {{ if .Param "rs-debug-enable" }}
      echo "+++++ START DEBUG: INPUT FROM TERRAFORM ++++++"
      jq . <<< "$TFSELF"
      echo "+++++ END DEBUG: INPUT FROM TERRAFORM ++++++"
      {{ end }}
      {{ end }}

      TFID=$(jq -rc ".id" <<< "${TFSELF}")
      TFNAME=$(jq -rc "$JQNAME" <<< "${TFSELF}")
      TFADDRESS=$(jq -rc "$JQADDRESS" <<< "${TFSELF}")

      EXISTS=$(drpcli machines count cloud/instance-id Eq "$TFID" cloud/provider Eq "{{$cloud}}")
      case $EXISTS in
        0) if drpcli machines exists Name:${TFNAME} > /dev/null ; then
             echo "  Looking for machine by Name $TFNAME"
             RAW=$(drpcli machines show Name:${TFNAME})
             MC=$(jq -rc '.Uuid' <<< "${RAW}")
           else
             echo "  No matching machine found"
           fi
           ;;
        1) echo "  Looking for $EXISTS instances with {{$cloud}}:$TFID."
           RAW=$(drpcli machines list cloud/instance-id Eq $TFID cloud/provider Eq {{$cloud}})
           MC=$(jq -rc '.[0].Uuid' <<< "${RAW}")
           ;;
        *) echo "ERROR: multiple matches for {{$cloud}}:$TFID!"
           exit 1
           ;;
      esac
      echo "  Machine is $TFNAME (Uuid $MC)."
      {{ if eq (.Param "terraform/plan-action") "apply" }}
      if [[ -z "$MC" ]]; then
        {{ range $i, $wf := (.Param "terraform/next-workflow") }}
        if [[ -z $WORKFLOW ]] ; then 
          if drpcli workflows exists $wf > /dev/null ; then
            WORKFLOW="{{$wf}}";
          fi
        fi
        echo "  selected $WORKFLOW as workflow"
        {{ else }}
        WORKFLOW="{{$wf}}"
        {{ end }}
        echo "  >>> Processing Terraform Apply to CREATE $TFNAME"
        RAW=$(drpcli machines create "{
          \"Name\":\"$TFNAME\",
          \"Fingerprint\":{\"CloudInstanceID\":\"{{$cloud}}:$TFID\"},
          \"Address\":\"$TFADDRESS\",
          \"Workflow\":\"$WORKFLOW\",
          {{- if .ParamExists "cluster/profile" -}}\"Profiles\":[\"{{ .Param "cluster/profile" }}\"],{{ end -}}
          \"Params\":{
            \"cloud/provider\":\"{{ $cloud }}\",
            \"cloud/instance-id\":\"$TFID\",
            {{- if .ParamExists "rsa/key-public" }}\"rsa/key-public\":\"{{ .Param "rsa/key-public"}}\",{{ end -}}
            \"terraform/plan-machine\":\"{{ .Machine.Uuid }}\",
            \"machine/type\":\"virtual\",
            \"machine/PXE\":false,
            \"machine/tags\":[\"Terraform\",\"virtual\",\"{{$cloud}}\"]
          },
          \"Meta\":{
            \"icon\":\"$CLOUDICON\"
          }
        }")
      else      
        echo "  >>> Processing Terraform Apply to UPDATE $MC"
        RAW=$(drpcli machines update $MC "{
          \"Name\":\"$TFNAME\",
          \"Fingerprint\":{\"CloudInstanceID\":\"{{$cloud}}:$TFID\"},
          \"Address\":\"$TFADDRESS\",
          \"Params\":{
            \"cloud/provider\":\"{{ $cloud }}\",
            \"cloud/instance-id\":\"$TFID\",
            {{- if .ParamExists "rsa/key-public" }}\"rsa/key-public\":\"{{ .Param "rsa/key-public"}}\",{{ end -}}
            \"terraform/plan-machine\":\"{{ .Machine.Uuid }}\",
            \"machine/type\":\"virtual\",
            \"machine/PXE\":false,
            \"machine/tags\":[\"Terraform\",\"virtual\",\"{{$cloud}}\"]
          },
          \"Meta\":{
            \"icon\":\"$CLOUDICON\"
          }
        }")
      fi
      MC=$(jq -rc .Uuid <<< "$RAW")
      echo "  Completed machine $MC action"
      echo "  Force Fingerprint via CURL (during v4.6 drpcli migration only)"
      curl -X PATCH --insecure \
        -H "Authorization: Bearer $RS_TOKEN" \
        -H "Content-Type: application/json" \
        -d "[{\"op\":\"replace\", \"path\":\"/Fingerprint/CloudInstanceID\", \"value\":\"{{$cloud}}:$TFID\"}]" \
        {{.ApiURL}}/api/v3/machines/$MC \
        > /dev/null
      {{ if .ParamExists "rsa/key-private" }}
      echo "  created/updated $MC.  setting private key"
      drpcli machines set $MC param rsa/key-private to - <<< '{{ .Param "rsa/key-private" }}' > /dev/null
      {{ end }}
      {{ else }}
      echo "  >>> Processing Terraform Destroy for $MC"
        if [[ "$MC" == "{{ .Machine.Uuid }}" ]]; then
        echo "  CLEAR TF data for $MC ..."
        drpcli machines update $MC '{"Address":"", "Fingerprint":{"CloudInstanceID":""}}' > /dev/null
        drpcli machines remove $MC param "cloud/provider" > /dev/null
        drpcli machines remove $MC param "cloud/instance-id" > /dev/null
        drpcli machines remove $MC param "terraform/plan-machine" > /dev/null
        drpcli machines remove $MC param "machine/PXE" > /dev/null
        drpcli machines remove $MC param "machine/type" > /dev/null
        drpcli machines remove $MC param "machine/tags" > /dev/null
        drpcli machines meta set $MC key icon to cube > /dev/null
      else
        echo "  DESTROY $MC ..."
        drpcli machines destroy $MC > /dev/mull
      fi
      {{ end }}

      echo "====== Completed $TFNAME ======"
      exit 0
  - Name: "DRP Variables"
    Path: "tf.vars"
    Contents: |-
      # automatically added by DRP terraform-apply
      variable "drp_url" {
        type      = string
        default   = "{{ .ProvisionerURL }}"
      }
      {{ if .ParamExists "rsa/key-public" }}variable "ssh_key" {
        type      = string
        default   = "{{ .Param "rsa/key-public" }}"
      }{{ end }}
      {{ if .ParamExists "rsa/key-user" }}variable "ssh_user" {
        type      = string
        default   = "{{ .Param "rsa/key-user" }}"
      }{{ end }}
      variable "machine_uuid" {
        type      = string
        default   = "{{ .Machine.Uuid }}"
      }
      variable "machine_name" {
        type      = string
        default   = "{{ .Machine.Name }}"
      }
      variable "machine_addr" {
        type      = string
        default   = "{{ .Machine.Address }}"
      }
      # end auto block

  - Name: "terraform-apply.sh"
    Contents: |-
      #!/bin/bash
      # RackN Copyright 2020

      set -e

      {{template "setup.tmpl" .}}
      chmod +x synchronize.sh

      {{ if $.ParamExists "rs-debug-enable" }}
      showplan={{ if eq ($.Param "rs-debug-enable") true }}true{{else}}false{{end}}
      {{ end }}
      tfstate="set"
      success=true
      echo "Retrieving terraform.tfstate file from machine"
      {{ if .ParamExists "terraform/tfstate" }}
      tee terraform.tfstate > /dev/null << EOF
      {{ .ParamAsJSON "terraform/tfstate" }}
      EOF
      if [[ $showplan == true ]]; then
        echo "DEBUG: terraform.tfstate"
        cat terraform.tfstate | jq .
      fi
      {{ else }}
      tfstate="add"
      if [[ -e terraform.tfstate ]] ; then
        echo "WARNING: tfstate file exists: uploading now, keeping in place"
        drpcli machines $tfstate $RS_UUID param terraform/tfstate to - < terraform.tfstate  > /dev/null
        drpcli machines $tfstate $RS_UUID param terraform/plan-machine to "{{.Machine.Uuid}}"  > /dev/null
      else
        echo "no terraform/tfstate exists"
      fi
      {{ end }}
      
      {{ $machine := .Machine.Name -}}
      {{ $action := .Param "terraform/plan-action" -}}
      {{ $templates := concat (.Param "terraform/plan-automation") (.Param "terraform/plan-templates") -}}
      {{ range $index, $plan := $templates -}}
      {{ $plan := printf "%s" $plan -}}

      ## Build Plan
      echo "============== Build Plan {{$index}}: {{$plan}} =============="
      echo "Building from Template {{ $plan }}"
      tee {{$plan}}.tf >/dev/null << EOF
      $(cat tf.vars)
      # >> start of {{$plan}}
      {{$.CallTemplate $plan $}}
      # << end of {{$plan}}
      EOF

      if [[ $showplan == true ]]; then
        echo "DEBUG: {{$plan}}.tf"
        cat {{$plan}}.tf
      fi

      echo "^^^^^ end of {{$plan}} loop ^^^^^ "
      {{ end }}

      ## this is a sad hack required by Terraform deprecation
      tfver=$(terraform -v)
      tf13reg="Terraform v0\.13\."
      if [[ $tfver =~ $tf13reg ]]; then
        echo "=== FORCE v0.13 UPGRADE ===="
        terraform 0.13upgrade -yes -no-color .
      else
        echo "=== NO v0.13 UPGRADE was $tfver ==== "
      fi

      echo "=== INIT $(terraform version) ===="

      terraform init -no-color

      if [[ $showplan == true ]]; then
        echo "=== PLAN (DEBUG) TERRAFORM ===="
        terraform plan -no-color
      fi

      echo "=== RUN {{ $action }} TERRAFORM ===="

      if terraform {{ $action }} -no-color -auto-approve ; then

        echo "terraform {{ $action }} succeeded!"

        out=$(terraform output --json | jq .)

        {{ if eq "apply" $action }}
        echo "******** APPLY POST ACTIONS ***********"

        if [[ $showplan == true ]]; then
          echo "DEBUG: output"
          echo "capturing terraform output: $out"
        fi
        ip=$(jq -r '.machine_ip.value' <<< ${out})
        if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
          echo "Detected IP from TF, Updateing Machine IP to $ip"
          drpcli machines update $RS_UUID "{\"Address\":\"$ip\"}" | jq .Address > /dev/null
        else
          echo "No IP address (machine_ip.value) detected in terraform output"
        fi

        # capture all the output vars in the parms
        echo "Uploading other keys from terraform output"
        for key in $(jq -r 'keys[]' <<< ${out}); do
          echo "  adding $key to machine"
          drpcli machines set $RS_UUID param "terraform-var/$key" to "\"$(jq -cr ".$key.value" <<< ${out})\""  > /dev/null
        done

        {{ else }}
            echo "******** DESTROY POST ACTIONS ***********"
            {{ if .ParamExists "terraform-var/machine_ip" }}
              echo "Clear IP and terraform-var/machine_ip when performing destroy with IP"
              drpcli machines update $RS_UUID "{\"Address\":\"\"}" | jq .Address
              drpcli machines remove $RS_UUID param terraform-var/machine_ip  > /dev/null 
            {{ else }}
              echo "Does not set IP, do not clear IP"
            {{ end }}
            echo "Always try to remove terraform/plan-automation, OK if fails"
            drpcli machines remove $RS_UUID param terraform/plan-automation  > /dev/null || true
        {{ end }}

      else
        success=false
        echo "terraform {{ $action }} failed!"

      fi

      if [[ -e terraform.tfstate ]] ; then
        if [[ "$(cat terraform.tfstate | jq -r '.resources | length')" == "0" ]] ; then
          echo "Removing empty terraform.tfstate file"
          drpcli machines remove $RS_UUID param terraform/tfstate > /dev/null || true
          drpcli machines remove $RS_UUID param terraform/plan-machine > /dev/null || true
        else
          echo "Saving terraform.tfstate file to machine"
          drpcli machines $tfstate $RS_UUID param terraform/tfstate to - < terraform.tfstate >/dev/null
          drpcli machines $tfstate $RS_UUID param terraform/plan-machine to "{{.Machine.Uuid}}"  > /dev/null || true
        fi
      else
        echo "no terraform.state file exists - cannot save"
        drpcli machines remove $RS_UUID param terraform/tfstate > /dev/null || true
        drpcli machines remove $RS_UUID param terraform/plan-machine  > /dev/null || true
      fi

      if [[ $success != true ]] ; then
        echo "Did not succeed - fail"
        exit 1
      fi

      echo "done"
      exit 0
Meta:
  icon: "map"
  color: "blue"
  title: "Digital Rebar Community Content"
  feature-flags: "sane-exit-codes"
